# Dijkstra’s Algorithm - Overview:

- Dijkstra's algorithm finds the shortest path from a source node to all other nodes in a weighted graph.

# Required Data Structures:

1) Adjacency List (vector<vector<pair<int, int>>> adj):

- Stores the graph where each node has a list of neighbors and weights (time or cost to reach them).
- Example: adj[u].push_back({v, w}) means there's an edge from node u to node v with weight w.

2) Distance Array (vector<int> dist):

- Keeps track of the shortest time (or distance) from the source node to all other nodes.
- Initially, all nodes are set to infinity (INT_MAX), except the source node which is set to 0.

3) Priority Queue (priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq):

- A min-heap used to efficiently get the node with the smallest distance (time) next.
- It stores pairs of (time, node) and helps in processing nodes in the correct order.


# Step-by-Step Explanation:

1) Adjacency List: vector<vector<pair<int, int>>> adj(n + 1) 
              stores the graph, where each node points to a list of pairs. Each pair is a (neighbor, weight).

2) Distance Vector: vector<int> dist(n + 1, INT_MAX) 
              initializes the distances to all nodes as "infinity" (large value), except for the source node k, which is initialized to 0.

3) Priority Queue: priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq 
              is used to process nodes with the smallest known distance. It ensures that we process nodes in order of their shortest known path.

4) Dijkstra's Main Loop:

- We extract the node with the smallest distance (pq.top()).
- We check all its neighbors and update their distances if a shorter path is found.

5) Final Answer:

- After processing all nodes, the maximum value in dist[] represents the time it takes for the signal 
  to reach the farthest node. If any node is still marked as unreachable (dist[i] == INT_MAX), return -1.



#  Implementation of Dijkstra’s algorithm using the necessary data structures:


#include <iostream>
#include <vector>
#include <queue>
#include <climits>

using namespace std;

class Solution {
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        // Step 1: Build the adjacency list
        vector<vector<pair<int, int>>> adj(n + 1);
        for (auto& time : times) {
            int u = time[0], v = time[1], w = time[2];
            adj[u].push_back({v, w});
        }
        
        // Step 2: Initialize distance vector with infinity, except for the source node k
        vector<int> dist(n + 1, INT_MAX);
        dist[k] = 0;
        
        // Step 3: Use a priority queue to store (time, node) pairs
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        pq.push({0, k});
        
        // Step 4: Main loop of Dijkstra's algorithm
        while (!pq.empty()) {
            int currentDist = pq.top().first;
            int node = pq.top().second;
            pq.pop();
            
            // Process all neighbors of the current node
            for (auto& neighbor : adj[node]) {
                int nextNode = neighbor.first;
                int weight = neighbor.second;
                
                // If a shorter path to nextNode is found, update the distance
                if (currentDist + weight < dist[nextNode]) {
                    dist[nextNode] = currentDist + weight;
                    pq.push({dist[nextNode], nextNode});
                }
            }
        }
        
        // Step 5: Find the maximum distance (the last signal to reach a node)
        int maxDist = 0;
        for (int i = 1; i <= n; i++) {
            if (dist[i] == INT_MAX) {
                return -1;  // Some node is unreachable
            }
            maxDist = max(maxDist, dist[i]);
        }
        
        return maxDist;
    }
};

// Example usage:
int main() {
    Solution sol;
    vector<vector<int>> times = {{2, 1, 1}, {2, 3, 1}, {3, 4, 1}};
    int n = 4, k = 2;
    
    int result = sol.networkDelayTime(times, n, k);
    cout << "Minimum time for all nodes to receive the signal: " << result << endl;

    return 0;
}
